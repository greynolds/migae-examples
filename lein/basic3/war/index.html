<html>
  <head>
    <title>Home Welcome!</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
    <script type="text/javascript" src="/js/migae.js"></script>
    <link rel="stylesheet" type="text/css" media="screen"
	  href="/css/migae.css"></link>
  </head>

  <body>
    <h1>Welcome to Home!</h1>

  <ul>
    <li>Test the "basic3.test" servlet by accessing <a href="/test/foo">/test/foo</a></li>
  </ul>

  <p>
    The first time you run this (i.e. access /test/*), you
    should see (in the console):
  </p>

  <pre>
    basic3.impl test-objinit invoked
    basic3.impl test-objpostinit invoked
    basic3.impl test-init method implementation invoked
    basic3.impl test-service method implementation invoked
  </pre>

  <p>
    (You won't see anything in the browser yet - at this point we only
    dump messages to the console.)
  </p>

  <p>
    The first two messages tell you that the :init and :post-init
    options specified in the :gen-class clause of basic3.test have been
    honored - they name functions that are called when the servlet
    constructor is called.  These are Clojure-specific functions; they
    get called before and after, respectively, the constructor of the
    gen-class'ed object is called.  In terms of the servlet
    life-cycle: when an HTTP request is received by the servlet
    container, it consults (in some way) the web.xml map to discover
    which servlet should handle the request.  It then searches for it
    on the classpath, loads it, and initializes it.  (Remember that
    :gen-class must be aot-compiled so that its byte-code ends up in
    war/WEB-INF/classes (or in a jarfile); otherwise the container
    would not be able to find it.  The Clojure runtime, which can find
    source code to load and evaluate, cannot be involved in the
    container's search and load logic.)  Which means it must call the
    constructor defined for the class.  Since we are in Clojure-land,
    what this means is that the Clojure-generated stub implementation
    of the class includes a constructor whose default behavior is just
    to call the superclass constructor.  These options - :init and
    :post-init - allow you to provide a Clojure function instead - the
    stub implementation will call these functions if you have
    specified them instead of going directly to the superclass.
  </p>

  <p>
    The next two messages - println'ed by test-init and test-service -
    demonstrate that the gen-class'ed stub (which, I remind you, is a
    plain old Java object generated by gen-class) is designed to
    "forward" calls to the Clojure functional implementations
    specified via the :impl-ns and :prefix options of :gen-class.  So
    what happens is this: the servlet container, having loaded the
    servlet, then invokes its "service" method.  The object that
    receives this is the Clojure-generated stub class, which is so
    arranged as to forward the call on to the Clojure functional
    implementation.  <b>This is handled by the Clojure runtime</b> -
    which means that it will look for a .clj source file if it cannot
    find a binary.  If it finds the clj file, it loads and evaluates
    it, yielding the implementation, which it then invokes.  Of
    course, that implementation is, under the covers, a Java class -
    which means that each Clojure function gets translated into a Java
    class with a single "method", so when the call to "service"
    happens, it gets turned into an action that loads the relevant
    class and invokes its "method".  In other words, what we have is
    an Object-Oriented regime simulating a Functional regime.  It
    looks like we've just called a function, but what really happens
    is that we instantiate an object and then "send the message"
    (which corresponds to the (source code) function) to that object.
  </p>

  <p>
    (Note that this only works under a plain servlet container without
    the kind of security restrictions found in dev_appserver.  The
    server must obviously be configure so that the source code is on
    the classpath, which you cannot do with dev_appserver if the
    source code is outside of the webapp directory structure.  See
    README.md for more info.)
  </p>


  <p>
    Thereafter each time you access /test/* you should see, in the console:
  </p>

  <pre>
    basic3.impl test-service method implementation invoked
  </pre>

  <p>
    That's just because the object has already been instantiated and
    initialized, so each "function call" has only to "send the
    message" that invokes the method - thus simulating a true function
    call.
  </p>

  </body>
</html>
